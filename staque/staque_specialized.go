// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package staque

type BoolStaque []bool

func NewBool() BoolStaque {
	return BoolStaque{}
}

func (staque BoolStaque) Push(xs ...bool) BoolStaque {
	return append(staque, xs...)
}

func (stk BoolStaque) Peekstk() (last bool, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que BoolStaque) Peekque() (first bool, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk BoolStaque) Popstk() (modified BoolStaque, last bool, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]bool, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que BoolStaque) Popque() (modified BoolStaque, first bool, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]bool, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type ByteStaque []byte

func NewByte() ByteStaque {
	return ByteStaque{}
}

func (staque ByteStaque) Push(xs ...byte) ByteStaque {
	return append(staque, xs...)
}

func (stk ByteStaque) Peekstk() (last byte, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que ByteStaque) Peekque() (first byte, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk ByteStaque) Popstk() (modified ByteStaque, last byte, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]byte, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que ByteStaque) Popque() (modified ByteStaque, first byte, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]byte, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Complex128Staque []complex128

func NewComplex128() Complex128Staque {
	return Complex128Staque{}
}

func (staque Complex128Staque) Push(xs ...complex128) Complex128Staque {
	return append(staque, xs...)
}

func (stk Complex128Staque) Peekstk() (last complex128, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Complex128Staque) Peekque() (first complex128, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Complex128Staque) Popstk() (modified Complex128Staque, last complex128, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]complex128, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Complex128Staque) Popque() (modified Complex128Staque, first complex128, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]complex128, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Complex64Staque []complex64

func NewComplex64() Complex64Staque {
	return Complex64Staque{}
}

func (staque Complex64Staque) Push(xs ...complex64) Complex64Staque {
	return append(staque, xs...)
}

func (stk Complex64Staque) Peekstk() (last complex64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Complex64Staque) Peekque() (first complex64, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Complex64Staque) Popstk() (modified Complex64Staque, last complex64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]complex64, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Complex64Staque) Popque() (modified Complex64Staque, first complex64, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]complex64, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type ErrorStaque []error

func NewError() ErrorStaque {
	return ErrorStaque{}
}

func (staque ErrorStaque) Push(xs ...error) ErrorStaque {
	return append(staque, xs...)
}

func (stk ErrorStaque) Peekstk() (last error, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que ErrorStaque) Peekque() (first error, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk ErrorStaque) Popstk() (modified ErrorStaque, last error, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]error, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que ErrorStaque) Popque() (modified ErrorStaque, first error, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]error, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Float32Staque []float32

func NewFloat32() Float32Staque {
	return Float32Staque{}
}

func (staque Float32Staque) Push(xs ...float32) Float32Staque {
	return append(staque, xs...)
}

func (stk Float32Staque) Peekstk() (last float32, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Float32Staque) Peekque() (first float32, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Float32Staque) Popstk() (modified Float32Staque, last float32, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]float32, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Float32Staque) Popque() (modified Float32Staque, first float32, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]float32, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Float64Staque []float64

func NewFloat64() Float64Staque {
	return Float64Staque{}
}

func (staque Float64Staque) Push(xs ...float64) Float64Staque {
	return append(staque, xs...)
}

func (stk Float64Staque) Peekstk() (last float64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Float64Staque) Peekque() (first float64, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Float64Staque) Popstk() (modified Float64Staque, last float64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]float64, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Float64Staque) Popque() (modified Float64Staque, first float64, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]float64, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type IntStaque []int

func NewInt() IntStaque {
	return IntStaque{}
}

func (staque IntStaque) Push(xs ...int) IntStaque {
	return append(staque, xs...)
}

func (stk IntStaque) Peekstk() (last int, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que IntStaque) Peekque() (first int, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk IntStaque) Popstk() (modified IntStaque, last int, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]int, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que IntStaque) Popque() (modified IntStaque, first int, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]int, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Int16Staque []int16

func NewInt16() Int16Staque {
	return Int16Staque{}
}

func (staque Int16Staque) Push(xs ...int16) Int16Staque {
	return append(staque, xs...)
}

func (stk Int16Staque) Peekstk() (last int16, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Int16Staque) Peekque() (first int16, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Int16Staque) Popstk() (modified Int16Staque, last int16, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]int16, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Int16Staque) Popque() (modified Int16Staque, first int16, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]int16, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Int32Staque []int32

func NewInt32() Int32Staque {
	return Int32Staque{}
}

func (staque Int32Staque) Push(xs ...int32) Int32Staque {
	return append(staque, xs...)
}

func (stk Int32Staque) Peekstk() (last int32, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Int32Staque) Peekque() (first int32, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Int32Staque) Popstk() (modified Int32Staque, last int32, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]int32, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Int32Staque) Popque() (modified Int32Staque, first int32, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]int32, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Int64Staque []int64

func NewInt64() Int64Staque {
	return Int64Staque{}
}

func (staque Int64Staque) Push(xs ...int64) Int64Staque {
	return append(staque, xs...)
}

func (stk Int64Staque) Peekstk() (last int64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Int64Staque) Peekque() (first int64, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Int64Staque) Popstk() (modified Int64Staque, last int64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]int64, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Int64Staque) Popque() (modified Int64Staque, first int64, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]int64, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Int8Staque []int8

func NewInt8() Int8Staque {
	return Int8Staque{}
}

func (staque Int8Staque) Push(xs ...int8) Int8Staque {
	return append(staque, xs...)
}

func (stk Int8Staque) Peekstk() (last int8, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Int8Staque) Peekque() (first int8, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Int8Staque) Popstk() (modified Int8Staque, last int8, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]int8, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Int8Staque) Popque() (modified Int8Staque, first int8, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]int8, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type RuneStaque []rune

func NewRune() RuneStaque {
	return RuneStaque{}
}

func (staque RuneStaque) Push(xs ...rune) RuneStaque {
	return append(staque, xs...)
}

func (stk RuneStaque) Peekstk() (last rune, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que RuneStaque) Peekque() (first rune, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk RuneStaque) Popstk() (modified RuneStaque, last rune, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]rune, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que RuneStaque) Popque() (modified RuneStaque, first rune, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]rune, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type StringStaque []string

func NewString() StringStaque {
	return StringStaque{}
}

func (staque StringStaque) Push(xs ...string) StringStaque {
	return append(staque, xs...)
}

func (stk StringStaque) Peekstk() (last string, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que StringStaque) Peekque() (first string, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk StringStaque) Popstk() (modified StringStaque, last string, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]string, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que StringStaque) Popque() (modified StringStaque, first string, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]string, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type UintStaque []uint

func NewUint() UintStaque {
	return UintStaque{}
}

func (staque UintStaque) Push(xs ...uint) UintStaque {
	return append(staque, xs...)
}

func (stk UintStaque) Peekstk() (last uint, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que UintStaque) Peekque() (first uint, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk UintStaque) Popstk() (modified UintStaque, last uint, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]uint, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que UintStaque) Popque() (modified UintStaque, first uint, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]uint, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Uint16Staque []uint16

func NewUint16() Uint16Staque {
	return Uint16Staque{}
}

func (staque Uint16Staque) Push(xs ...uint16) Uint16Staque {
	return append(staque, xs...)
}

func (stk Uint16Staque) Peekstk() (last uint16, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Uint16Staque) Peekque() (first uint16, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Uint16Staque) Popstk() (modified Uint16Staque, last uint16, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]uint16, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Uint16Staque) Popque() (modified Uint16Staque, first uint16, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]uint16, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Uint32Staque []uint32

func NewUint32() Uint32Staque {
	return Uint32Staque{}
}

func (staque Uint32Staque) Push(xs ...uint32) Uint32Staque {
	return append(staque, xs...)
}

func (stk Uint32Staque) Peekstk() (last uint32, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Uint32Staque) Peekque() (first uint32, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Uint32Staque) Popstk() (modified Uint32Staque, last uint32, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]uint32, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Uint32Staque) Popque() (modified Uint32Staque, first uint32, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]uint32, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Uint64Staque []uint64

func NewUint64() Uint64Staque {
	return Uint64Staque{}
}

func (staque Uint64Staque) Push(xs ...uint64) Uint64Staque {
	return append(staque, xs...)
}

func (stk Uint64Staque) Peekstk() (last uint64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Uint64Staque) Peekque() (first uint64, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Uint64Staque) Popstk() (modified Uint64Staque, last uint64, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]uint64, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Uint64Staque) Popque() (modified Uint64Staque, first uint64, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]uint64, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type Uint8Staque []uint8

func NewUint8() Uint8Staque {
	return Uint8Staque{}
}

func (staque Uint8Staque) Push(xs ...uint8) Uint8Staque {
	return append(staque, xs...)
}

func (stk Uint8Staque) Peekstk() (last uint8, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que Uint8Staque) Peekque() (first uint8, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk Uint8Staque) Popstk() (modified Uint8Staque, last uint8, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]uint8, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que Uint8Staque) Popque() (modified Uint8Staque, first uint8, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]uint8, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}

type UintptrStaque []uintptr

func NewUintptr() UintptrStaque {
	return UintptrStaque{}
}

func (staque UintptrStaque) Push(xs ...uintptr) UintptrStaque {
	return append(staque, xs...)
}

func (stk UintptrStaque) Peekstk() (last uintptr, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return last, emptypeek
	}
	return stk[ilast], nil
}

func (que UintptrStaque) Peekque() (first uintptr, isempty error) {
	if len(que) == 0 {
		return first, emptypeek
	}
	return que[0], nil
}

func (stk UintptrStaque) Popstk() (modified UintptrStaque, last uintptr, isempty error) {
	ilast := len(stk) - 1
	if ilast < 0 {
		return nil, last, emptypop
	}

	if ilast < cap(stk)/4 {
		return append(make([]uintptr, 0, cap(stk)/2), stk[:ilast]...), stk[ilast], nil
	} else {
		return stk[:ilast], stk[ilast], nil
	}
}

func (que UintptrStaque) Popque() (modified UintptrStaque, first uintptr, isempty error) {
	len := len(que)
	if len == 0 {
		return nil, first, emptypop
	}

	if len > cap(que)/4 {
		return que[1:], que[0], nil
	} else {
		return append(make([]uintptr, 0, cap(que)/2), que[1:]...), que[0], nil
	}
}
