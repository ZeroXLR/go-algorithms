// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package staque

type BoolStaque []bool

func NewBool() BoolStaque {
	return BoolStaque{}
}

func (staque *BoolStaque) Push(xs ...bool) {
	*staque = append(*staque, xs...)
}

func (stk *BoolStaque) Peekstk() (last bool, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *BoolStaque) Peekque() (first bool, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *BoolStaque) Popstk() (last bool, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]bool, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *BoolStaque) Popque() (first bool, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]bool, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type ByteStaque []byte

func NewByte() ByteStaque {
	return ByteStaque{}
}

func (staque *ByteStaque) Push(xs ...byte) {
	*staque = append(*staque, xs...)
}

func (stk *ByteStaque) Peekstk() (last byte, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *ByteStaque) Peekque() (first byte, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *ByteStaque) Popstk() (last byte, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]byte, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *ByteStaque) Popque() (first byte, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]byte, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Complex128Staque []complex128

func NewComplex128() Complex128Staque {
	return Complex128Staque{}
}

func (staque *Complex128Staque) Push(xs ...complex128) {
	*staque = append(*staque, xs...)
}

func (stk *Complex128Staque) Peekstk() (last complex128, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Complex128Staque) Peekque() (first complex128, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Complex128Staque) Popstk() (last complex128, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]complex128, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Complex128Staque) Popque() (first complex128, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]complex128, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Complex64Staque []complex64

func NewComplex64() Complex64Staque {
	return Complex64Staque{}
}

func (staque *Complex64Staque) Push(xs ...complex64) {
	*staque = append(*staque, xs...)
}

func (stk *Complex64Staque) Peekstk() (last complex64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Complex64Staque) Peekque() (first complex64, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Complex64Staque) Popstk() (last complex64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]complex64, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Complex64Staque) Popque() (first complex64, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]complex64, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type ErrorStaque []error

func NewError() ErrorStaque {
	return ErrorStaque{}
}

func (staque *ErrorStaque) Push(xs ...error) {
	*staque = append(*staque, xs...)
}

func (stk *ErrorStaque) Peekstk() (last error, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *ErrorStaque) Peekque() (first error, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *ErrorStaque) Popstk() (last error, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]error, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *ErrorStaque) Popque() (first error, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]error, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Float32Staque []float32

func NewFloat32() Float32Staque {
	return Float32Staque{}
}

func (staque *Float32Staque) Push(xs ...float32) {
	*staque = append(*staque, xs...)
}

func (stk *Float32Staque) Peekstk() (last float32, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Float32Staque) Peekque() (first float32, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Float32Staque) Popstk() (last float32, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]float32, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Float32Staque) Popque() (first float32, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]float32, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Float64Staque []float64

func NewFloat64() Float64Staque {
	return Float64Staque{}
}

func (staque *Float64Staque) Push(xs ...float64) {
	*staque = append(*staque, xs...)
}

func (stk *Float64Staque) Peekstk() (last float64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Float64Staque) Peekque() (first float64, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Float64Staque) Popstk() (last float64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]float64, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Float64Staque) Popque() (first float64, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]float64, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type IntStaque []int

func NewInt() IntStaque {
	return IntStaque{}
}

func (staque *IntStaque) Push(xs ...int) {
	*staque = append(*staque, xs...)
}

func (stk *IntStaque) Peekstk() (last int, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *IntStaque) Peekque() (first int, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *IntStaque) Popstk() (last int, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]int, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *IntStaque) Popque() (first int, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]int, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Int16Staque []int16

func NewInt16() Int16Staque {
	return Int16Staque{}
}

func (staque *Int16Staque) Push(xs ...int16) {
	*staque = append(*staque, xs...)
}

func (stk *Int16Staque) Peekstk() (last int16, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Int16Staque) Peekque() (first int16, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Int16Staque) Popstk() (last int16, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]int16, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Int16Staque) Popque() (first int16, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]int16, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Int32Staque []int32

func NewInt32() Int32Staque {
	return Int32Staque{}
}

func (staque *Int32Staque) Push(xs ...int32) {
	*staque = append(*staque, xs...)
}

func (stk *Int32Staque) Peekstk() (last int32, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Int32Staque) Peekque() (first int32, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Int32Staque) Popstk() (last int32, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]int32, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Int32Staque) Popque() (first int32, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]int32, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Int64Staque []int64

func NewInt64() Int64Staque {
	return Int64Staque{}
}

func (staque *Int64Staque) Push(xs ...int64) {
	*staque = append(*staque, xs...)
}

func (stk *Int64Staque) Peekstk() (last int64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Int64Staque) Peekque() (first int64, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Int64Staque) Popstk() (last int64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]int64, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Int64Staque) Popque() (first int64, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]int64, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Int8Staque []int8

func NewInt8() Int8Staque {
	return Int8Staque{}
}

func (staque *Int8Staque) Push(xs ...int8) {
	*staque = append(*staque, xs...)
}

func (stk *Int8Staque) Peekstk() (last int8, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Int8Staque) Peekque() (first int8, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Int8Staque) Popstk() (last int8, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]int8, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Int8Staque) Popque() (first int8, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]int8, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type RuneStaque []rune

func NewRune() RuneStaque {
	return RuneStaque{}
}

func (staque *RuneStaque) Push(xs ...rune) {
	*staque = append(*staque, xs...)
}

func (stk *RuneStaque) Peekstk() (last rune, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *RuneStaque) Peekque() (first rune, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *RuneStaque) Popstk() (last rune, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]rune, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *RuneStaque) Popque() (first rune, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]rune, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type StringStaque []string

func NewString() StringStaque {
	return StringStaque{}
}

func (staque *StringStaque) Push(xs ...string) {
	*staque = append(*staque, xs...)
}

func (stk *StringStaque) Peekstk() (last string, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *StringStaque) Peekque() (first string, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *StringStaque) Popstk() (last string, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]string, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *StringStaque) Popque() (first string, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]string, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type UintStaque []uint

func NewUint() UintStaque {
	return UintStaque{}
}

func (staque *UintStaque) Push(xs ...uint) {
	*staque = append(*staque, xs...)
}

func (stk *UintStaque) Peekstk() (last uint, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *UintStaque) Peekque() (first uint, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *UintStaque) Popstk() (last uint, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]uint, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *UintStaque) Popque() (first uint, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]uint, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Uint16Staque []uint16

func NewUint16() Uint16Staque {
	return Uint16Staque{}
}

func (staque *Uint16Staque) Push(xs ...uint16) {
	*staque = append(*staque, xs...)
}

func (stk *Uint16Staque) Peekstk() (last uint16, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Uint16Staque) Peekque() (first uint16, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Uint16Staque) Popstk() (last uint16, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]uint16, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Uint16Staque) Popque() (first uint16, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]uint16, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Uint32Staque []uint32

func NewUint32() Uint32Staque {
	return Uint32Staque{}
}

func (staque *Uint32Staque) Push(xs ...uint32) {
	*staque = append(*staque, xs...)
}

func (stk *Uint32Staque) Peekstk() (last uint32, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Uint32Staque) Peekque() (first uint32, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Uint32Staque) Popstk() (last uint32, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]uint32, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Uint32Staque) Popque() (first uint32, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]uint32, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Uint64Staque []uint64

func NewUint64() Uint64Staque {
	return Uint64Staque{}
}

func (staque *Uint64Staque) Push(xs ...uint64) {
	*staque = append(*staque, xs...)
}

func (stk *Uint64Staque) Peekstk() (last uint64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Uint64Staque) Peekque() (first uint64, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Uint64Staque) Popstk() (last uint64, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]uint64, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Uint64Staque) Popque() (first uint64, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]uint64, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type Uint8Staque []uint8

func NewUint8() Uint8Staque {
	return Uint8Staque{}
}

func (staque *Uint8Staque) Push(xs ...uint8) {
	*staque = append(*staque, xs...)
}

func (stk *Uint8Staque) Peekstk() (last uint8, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *Uint8Staque) Peekque() (first uint8, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *Uint8Staque) Popstk() (last uint8, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]uint8, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *Uint8Staque) Popque() (first uint8, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]uint8, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}

type UintptrStaque []uintptr

func NewUintptr() UintptrStaque {
	return UintptrStaque{}
}

func (staque *UintptrStaque) Push(xs ...uintptr) {
	*staque = append(*staque, xs...)
}

func (stk *UintptrStaque) Peekstk() (last uintptr, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Peek() on empty staque")
	}
	return (*stk)[ilast], err
}

func (que *UintptrStaque) Peekque() (first uintptr, err error) {
	if len(*que) == 0 {
		return first, Empty("Cannot Peek() on empty staque")
	}
	return (*que)[0], err
}

func (stk *UintptrStaque) Popstk() (last uintptr, err error) {
	ilast := len(*stk) - 1
	if ilast < 0 {
		return last, Empty("Cannot Pop() on empty staque")
	}

	last = (*stk)[ilast]
	if ilast < cap(*stk)/4 {
		*stk = append(make([]uintptr, 0, cap(*stk)/2), (*stk)[:ilast]...)
	} else {
		*stk = (*stk)[:ilast]
	}
	return last, err
}

func (que *UintptrStaque) Popque() (first uintptr, err error) {
	len := len(*que)
	if len == 0 {
		return first, Empty("Cannot Pop() on empty staque")
	}

	first = (*que)[0]
	if len > cap(*que)/4 {
		*que = (*que)[1:]
	} else {
		*que = append(make([]uintptr, 0, cap(*que)/2), (*que)[1:]...)
	}
	return first, err
}
